---
title: "Zachary_Levine_Math747_A1.R"
author: "Zachary Levine"
date: '2020-10-27'
output: 
  pdf_document:
      includes:
        in_header: 4mbapreamble.tex
      extra_dependencies: ["flafter"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.pos = "!H", out.extra = "")
```

## Importing libraries and loading data

```{r echo=FALSE, message= FALSE, warning=FALSE, dev="tikz", results="hide"}
library(epigrowthfit)
library(tikzDevice)
library(Hmisc)
library(dplyr)
library(anytime)
library(chron)

covid.canada.filename <- "COVID19_Canada.csv"
#This gives a data.frame of prevalence for all proviences and all dates.
##Exclude Nunavut, since no reported cases.
allcases <- read.csv(covid.canada.filename)[,c("Province", "Date", "confirmed_positive", "Note")]
##Turn that into a list of each province's interval reported cases time series.
##Get rid of rows with duplicate dates, such as (NL-2020-03-25), by removing the duplicated date and adding its case reports to first report for that date.
##First grab the indices of the original dates one row above the repeated dates.

originalDateIndices <- (diff(anytime::anydate(allcases$Date)) == 0)[c(2:length(diff(anytime::anydate(allcases$Date)) == 0), FALSE)]
##Add the second case report to the first.
allcases[originalDateIndices, "confirmed_positive"] <- allcases[originalDateIndices, "confirmed_positive"] + allcases[diff(anytime::anydate(allcases$Date)) == 0, "confirmed_positive"]
##Get rid of the duplicate dates.
allcases <- allcases[!diff(anytime::anydate(allcases$Date)) == 0,]
##For each province, holds the index for the start of the waves
##Quebec fit for both waves won't be great because for both waves there is a period of exponential growth but the peak of the wave isn't reached, then we stop growing exponentially and then start again briefly before the peak. End the fitting window when growth becomes sub exponetial, regardless of if peak has occured yet.
##BC grows slowly in the second wave for a bit until growth becomes exponential. Thus, the initial growth rate isn't strongly representative of the initial phase of the second wave. MB data displays the same trend but on a smaller scale.
##SK has multiple mini waves before a big one starting late October, not just two waves. We chose the biggest two to be the ones to study, but this may not have been the best choice. At least three mini waves occur before what we denote as the first wave. May have been better to fit to them.
##Only one real epidemic wave in NL. Fit the secon wave to a mostly flat second epidemic wave consiting of less than 5 cases at peak. Unclear if this makes any sense.
##NB has a very small wave in between the two epidemic waves we fit. Didn't fit to it because to the other two were much larger in magnitude.
##Second wave in NS is tiny.
##PEI actually has four epidemic waves, the final three being very similar in size.
##YT has very small peaks (1), but if we consider that as a wave than there are at least of them.
##Fitting were determined for the most part by visual inspection.
#Only one wave in NL
wave1beginings <- c("ON" = 11, "AB" = 2, "QC" = 5, "BC" = 1, "SK" = 5, "MB" = 1, "NL" = 1, "NB" = 1, "NS" = 1, "PEI" = 1, "YT" = 1, "NT" = 1, "NU" = NA)
wave1endings <- c("ON" = 77 , "AB" = 38, "QC" = 29, "BC" = 9, "SK" = 16, "MB" = 16, "NL" = 7, "NB" = 19, "NS" = 34, "PEI" = 12, "YT" = 7, "NT" = 22, "NU" = NA)
wave2beginings <- list("ON" = 188, "AB" = 133, "QC" = 185, "BC" = 151, "SK" = 194, "MB" = 195, "NL" = 221, "NB" = 185, "NS" = 220, "PEI" = 163, "YT" = 201, "NT" = 200, "NU" = NA)
##Pass "end" to the pipeline to specify that we should end the second wave at the last possible observation date.
wave2endings <- c("ON" = "end", "AB" = 173, "QC" = 212, "BC" = "end" , "SK" = "end", "MB" = "end", "NL" = 229, "NB" = 210, "NS" = "end", "PEI" = 174, "YT" = 216 , "NT" = 214, "NU" = NA)
splitintervalCases <- lapply(as.vector(unique(allcases$Province)), function(provinceName){
  ##For each province, select all the data corresponding to that province.
  casesdf <- allcases[as.vector(allcases$Province) == provinceName,]
  ##Get rid of missing values.
  casesdf <- casesdf[!is.na(casesdf$"confirmed_positive"),]
  ##Derive interval incidence by differencing (discarding the first reported entry to align all the columns and keep them the same length), keeping the column for each provience as a check to make sure we're doing everthing properly.
intervalcasesdf <- bind_cols("Date" = casesdf$"Date",
                           "Province" =  casesdf$"Province",
                           "Note" = casesdf$"Note",
                           "intervalCases" = c(0, diff(casesdf$"confirmed_positive", lag = 1)))
  ##Some row of contain a negative value, so let's get rid of them
  intervalcasesdf <- intervalcasesdf[intervalcasesdf$intervalCases >= 0,]
  ##Make a list of sums of weekend case reports such that the ith element is the sum of the reported cases on Saturday and Sunday for the ith weekend.
  if (provinceName == "BC" || provinceName  == "AB"){
  weekendSums <- as.list(intervalcasesdf[ format(as.Date(anytime::anydate(intervalcasesdf$Date)), '%A') == "Saturday","intervalCases"])$intervalCases +
  as.list(intervalcasesdf[format(as.Date(anytime::anydate(intervalcasesdf$Date)), '%A') == "Sunday","intervalCases"])$intervalCases
  mondayIndices <- format(as.Date(anytime::anydate(intervalcasesdf$Date)), '%A') == "Monday"
  ##If the weekend reports were zero and the monday report was not, assume improper reporting and make the Monday cases the sum of the Monday cases the case reports on the weekends.
  intervalcasesdf[mondayIndices,"intervalCases"] <- c(0, weekendSums[1:length(weekendSums)-1]) + intervalcasesdf[mondayIndices,"intervalCases"]
  ##Remove the weekends.
  intervalcasesdf <- intervalcasesdf[!is.weekend(anytime::anydate(intervalcasesdf$Date)),]
  }
  else{
  }
  return(intervalcasesdf)
  })
names(splitintervalCases) <- as.vector(unique(allcases$Province))

##Make a list of instantiated egf objects for each wave and each province.
##We have to difference the cumulative cases to get interval cases, but in doing so we get rid of the first case report. Set it to zero to make the data frame with all columns of the same length, but get rid of it before initializing egf objects.
##Each element of egfs is a list for the corresponding province containing the egf_init object for the first wave and the second wave separately.
egfs <- sapply(names(splitintervalCases)[names(splitintervalCases) != "NU"], function(provinceName){
  beginingwave1 <- as.numeric(wave1beginings[provinceName])
  beginingwave2 <- as.numeric(wave2beginings[provinceName])
  endingwave1 <- as.numeric(wave1endings[provinceName])
  endingwave2 <- wave2endings[provinceName]
    provincetimeseries <- data.frame(splitintervalCases[names(splitintervalCases) == provinceName])[4][,1][1:length(data.frame(splitintervalCases[names(splitintervalCases) == provinceName])[4][,1])]
  dates <- anytime::anydate(data.frame(splitintervalCases[names(splitintervalCases) == provinceName])[1][,1])
    if (endingwave2 == "end"){
    endingwave2 <- length(provincetimeseries)
  }
  else{
    ##Class system gets a bit messed up for some reason.
        endingwave2 <- as.numeric(endingwave2)
  }
  ##We get better fits for some provinces with this stuff.
  if (provinceName %in% c("QC", "BC", "NL")){
    if (provinceName =="NL"){
      theFirst <- egf_init(cases = nn$intervalCases, date = anytime::anydate(nn$Date), first = 1, last = 9)
    }
    else{
    theFirst <- egf_init(date = dates, cases = provincetimeseries, first = beginingwave1, last = endingwave1)    }
    if (provinceName == "QC"){
    theSecond <- (egf_init(cases = splitintervalCases$QC$intervalCases, date = anydate(splitintervalCases$QC$Date), first = 165, peak = 212))
    }
    else{
          theSecond <- egf_init(cases = provincetimeseries, date = dates, first = beginingwave2)
    }
  }
  else{
    theFirst <- egf_init(date = dates, cases = provincetimeseries, first = beginingwave1, last = endingwave1)
    theSecond <- egf_init(date = dates, cases = provincetimeseries, first = beginingwave2, last = endingwave2)
  }
  return(list("first" = theFirst,
              "second" = theSecond
)
         )
  })
names(egfs) <- names(splitintervalCases)[names(splitintervalCases) != "NU"]
egfs <- data.frame(egfs)
```

Instantiate tables for each wave.
```{r, echo = FALSE}
##Make a table of results for the egf objects in a list.
make_table <- function(egflist){
  return(data.frame("Province" = as.vector(names(egflist)),
                         "Exponential Growth Rate" = sapply(egflist, function(x){
                           return(x$theta0[1])}),
                         "Doubling Time"= sapply(egflist, epigrowthfit::compute_doubling_time),
                         "Reproduction Number" = sapply(1:length(egflist), function(x){return(1)})))
}
#table1 <- make_table(wave1egfs)
```

```{r}
##To check model fits.
i <- 7
while (i <= length(egfs)){
  print(colnames(egfs[i]))
  plot(egf(egfs[[1, colnames(egfs[i])]]))
  plot(egf(egfs[[2, colnames(egfs[i])]]))
  i <- i+ 1
}
##To find fititing windows.
#plot(smooth_cases(date = anydate(splitintervalCases$NL$Date), cases = splitintervalCases$NL$intervalCases, spar = 0.25, log = TRUE))
```


Table for the second wave.
```{r, results = "asis"}

##Contains how to push the labels for doubling time off the curve.
##plot(egf(egfs$ON$first),style = list("text_dbl" = c("offset" = 15)), annotate = TRUE)

options(omitlatexcom = TRUE)
#Hmisc::latex(table1, title = "", rowname = "", file = "")
```